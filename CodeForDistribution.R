library("wavelets")library("mvtnorm")datafile <- "E-MEXP-54-processed-data-1341925120.txt"

set.seed(1)
plot.wv <- function(Theta, Data, type=c("all.means", "single.cluster"), j){	r <- log(ncol(Data$Y)/ncol(Data$Z), 2)	W <- Theta$W	J <- ncol(W)	iw <- function(i, r)	{		wnew <- W[,i]		j <- 1		f <- function(i, ws) c(ws[i]/sqrt(2), ws[i]/sqrt(2))		while(j <= r) {			wnew <- as.vector(sapply(1:length(wnew), f, wnew))			j <- j+1		}		return(wnew)	}		means.plot <- function(Theta, Data)	{		MU <- sapply(1:J, iw, r=r)		clrs <- rainbow(J)		plot(Data$tm, MU[,1], type="n", ylim=c(min(MU), max(MU)), 			xlab = "Time (min)", 			ylab="Normalized Expression")			for(i in 1:J) points(Data$tm, MU[,i], type="l", lwd=3,			col=clrs[i])	}		cluster.plot <- function(Theta, Data, j)	{		MU <- iw(j,r)						ind <- which(Theta$P[,j] > .9)		cldat <- Data$Y[ind,]		plot(Data$tm, cldat[1,], ylim=c(min(cldat), max(cldat)), type="n", 			xlab = "Time (min)",			ylab = "Normalized Expression",			main = paste("Cluster", j))		for(i in 1L:nrow(cldat)) {			points(Data$tm, cldat[i,], pch = 19, col="#0000FF30")		}		lines(Data$tm, MU, col="black")	}					type <- match.arg(type)	switch(type, 		all.means=means.plot(Theta, Data),		single.cluster=cluster.plot(Theta, Data, j)	)}update.p <- function(Theta, Data, MP){	ngene <- MP$ngene	POld <- Theta$P	sigsq <- Theta$Var$sigsq	W <- Theta$W	Z <- Data$Z	J <- MP$J	omega <- Theta$omega		Sig <- build.sig(Theta, Data, MP)		oneterm <- function(i,j)			{		f <- function(i,j) {			omega[j] * dmvnorm(Z[i,], W[,j], Sig)		}			mapply(f, i, j)	}			PRaw <- outer(1:ngene, 1:J, oneterm)	denom <- rowSums(PRaw)	PNew <- PRaw/denom	PNew[is.nan(PNew)] <- POld[is.nan(PNew)]	PNew}update.omega <- function(Theta) colMeans(Theta$P)filter.y <- function(Data, MP){	r <- MP$r	ngene <- MP$ngene	Y <- Data$Y	matrix(dwt(t(Y), "haar", r)@V[[paste("V", r, sep="")]], 		nrow=ngene, byrow=TRUE)}update.W <- function(Theta, Data, MP) {	Z <- Data$Z	P <- Theta$P	(t(Z) %*% P) %*% diag(1/colSums(P))}#Result should be a K by J matrix, where K each colum is the #new estimated mean for group jbuild.sig <- function(Theta, Data, MP, rho) {	if(missing(rho)) rho <- Theta$Var$rho	M <- MP$M	sigsq <- Theta$Var$sigsq		sigsq*toeplitz(rho^(0:(M-1)))}build.siginv <- function(Theta, Data, MP, rho) {	M <- MP$M	sigsq <- Theta$Var$sigsq	if(missing(rho)) rho <- Theta$Var$rho		tmp <- toeplitz(c(1+rho^2, -rho, rep(0, M-2)))	tmp[1,1] <- tmp[M,M] <- 1	tmp/(sigsq*(1-rho^2))}update.sigsq <- function(Theta, Data, MP) {	ngene <- MP$ngene	J <- MP$J	M <- MP$M	Z <- Data$Z	W <- Theta$W	P <- Theta$P	SigInvNorm <- build.siginv(Theta, Data, MP)*Theta$Var$sigsq	oneterm <- function(i,j) {		f <- function(i, j) {			P[i,j]*(Z[i,] - W[,j]) %*% 				SigInvNorm %*% (Z[i,] - W[,j])		}		mapply(f,i,j)	}		sum(outer(1:ngene, 1:J, oneterm))/(ngene*M)}update.rho <- function(Theta, Data, MP) {	P <- Theta$P	omega <- Theta$omega	ngene <- MP$ngene	rho <- Theta$Var$rho	sigsq <- Theta$Var$sigsq	J <- MP$J	M <- MP$M	Z <- Data$Z	W <- Theta$W		build.d1mat <- function(rho) {		a1 <- (2*rho/(1-rho^2)^2)*(1+rho^2)+2*rho/(1-rho^2)		a2 <- (-2*rho^2/(1-rho^2)^2) - 1/(1-rho^2)		tmp <- toeplitz(c(a1, a2, rep(0, M-2)))		tmp[1,1] <- tmp[M,M] <- 2*rho/(1-rho^2)^2		tmp	}		build.d2mat <- function(rho) {		m1 <- toeplitz(c(1+rho^2, -rho, rep(0, M-2)))		m1[1,1] <- m1[M,M] <- 1		m2 <- toeplitz(c(2*rho, -1, rep(0, M-2)))		m2[1,1] <- m2[M,M] <- 0		m3 <- diag(c(0, rep(2, M-2), 0))				((2*(1-rho^2)+8*rho^2)/(1-rho^2)^3)*m1 +			((4*rho)/(1-rho^2)^2)*m2 + (1/(1-rho^2))*m3	}			d1 <- function(rho) {		d1mat <- build.d1mat(rho)		oneterm <- function(i,j) {			f <- function(i,j) {				P[i,j]*((M-1)*rho/(1-rho^2) - 					(1/(2*sigsq)) *	(Z[i,] - W[,j]) %*% d1mat %*% 						(Z[i,] - W[,j]))			}			mapply(f, i, j)		}				sum(outer(1:ngene, 1:J, oneterm))	}		d2 <- function(rho) {		d2mat <- build.d2mat(rho)		oneterm <- function(i,j) {			f <- function(i,j) {				P[i,j]*((M-1)*(1+rho^2)/(1-rho^2)^2 - 					(1/(2*sigsq)) *	(Z[i,] - W[,j]) %*% d2mat %*% 						(Z[i,] - W[,j]))			}			mapply(f, i, j)		}				sum(outer(1:ngene, 1:J, oneterm))	}		rho.new <- rho - d1(rho)/d2(rho)	if(abs(rho.new) >= 1) sign(rho.new)*.5	else rho.new}continue.em <- function(Theta.old, Theta, epsConv){	delta <- max(abs(		unlist(Theta.old[-match("ll", names(Theta.old))]) - 		unlist(Theta[-match("ll", names(Theta))])))	cat("delta =", delta, "   epsConv =", epsConv, "\n")		if ( delta < epsConv ) return(FALSE)	else return(TRUE)}BiglogL <- function(Theta, Data, MP) {	P <- Theta$P		omega <- Theta$omega	J <- MP$J	K <- MP$K	Z <- Data$Z	W <- Theta$W	M <- MP$M		ngene <- MP$ngene	Sig <- build.sig(Theta, Data, MP)	SigInv <- build.siginv(Theta, Data, MP)	oneterm <- function(i, j) {		f <- function(i,j) 			P[i,j]*(log(omega[j]) - M*log(2*pi)/2 - log(det(Sig))/2				- (Z[i,] - W[,j]) %*% SigInv %*% (Z[i,] - W[,j])/2)		mapply(f, i, j)		}	tmp <- outer(1:ngene, 1:J, oneterm)	tmp[!is.finite(tmp)] <- min(tmp[is.finite(tmp)])	sum(tmp)}runEM <- function(Theta, Data, MP, CP){		max.iter <- CP$max.iter	eps.conv <- CP$eps.conv		CONT <- TRUE	iter <- 0		while(CONT)	{		iter <- iter + 1		Theta.old <- Theta		Theta <- ee(Theta, Data, MP)		Theta <- em(Theta, Data, MP, CP, iter)		Theta$ll <- BiglogL(Theta, Data, MP)		if(CP$print.updates) {			cat("Theta:\n")			print(Theta$omega)			print(Theta$Mu)			print(Theta$Var)		}		CONT <- continue.em(Theta.old, Theta, eps.conv)		if(iter >= max.iter) CONT <- FALSE		if(CP$print.updates) {			cat("Log Likelihood:", Theta$ll, "\n")			cat("iteration = ", iter, "\n\n\n")		}	}		return(list(Theta = Theta, Data = Data))}		ee <- function(Theta, Data, MP){	Theta$P <- update.p(Theta, Data, MP)	return(Theta)}em <- function(Theta, Data, MP, CP, iter) {	Theta$omega <- update.omega(Theta)		Theta$W <- update.W(Theta, Data, MP)  	Theta$Var$sigsq <- update.sigsq(Theta,Data, MP)	if( iter > CP$ar.skip )		Theta$Var$rho <- update.rho(Theta, Data, MP)	return(Theta)}init.n.run <- function(J=9, r=2){	tmp <- read.table(datafile, skip=2, row.names=1, na.string = "null")	tmp <- as.matrix(tmp)	colnames(tmp) <- NULL	keep.rows <- apply(tmp, 1, function(rw) !any(is.na(rw)))	dat <- tmp[keep.rows,]	ngene <- nrow(dat)		times <- c(1, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 		180, 195, 210, 225, 240, 255, 270, 285)	if(length(times) %% 2^r != 0) stop("Dimension Reduction too great")		Data <- list(Y = dat, Z = NULL, tm = times)	MP <- list(J=J, r=r, ngene=ngene, M=length(times)/(2^r))	CP <- list(max.iter=60, eps.conv=.02, ar.skip=3, print.updates=TRUE)	Data$Z <- filter.y(Data, MP)		om.init <- c(rep(.25/(J-1), J-1), .75)	P.init <- runif(ngene*J)	dim(P.init) <- c(ngene, J)	for(i in 1:ngene) P.init[i,] <- P.init[i,]/sum(P.init[i,])	W <- matrix(rnorm(MP$M*MP$J, mean=sqrt(2)^r), nrow = MP$M, ncol=J)	W[,J] <- sqrt(2)^r	rho <- 0		Theta <- list(		omega = om.init, 		P = P.init, 		W=W, 		Var = list(	rho= rho, 					sigsq = 10), 		ll = -Inf	)			runEM(Theta, Data, MP, CP)}# init.n.run sets the initial values for the parameters# and then runs the EM algorithm.  J is the number of # clusters, and r is the level of wavelet smoothing, # with r=0 corresponding to the raw data.mod <- init.n.run(J=13, r=1)Theta <- mod$ThetaData <- mod$Data# The first plot shows the fitted means for all clustersquartz(width=9, height=5)par(mar=(c(4,4,1,1)+.1), ask=TRUE)plot.wv(Theta, Data, "a")# The second set of plots shows individual clusters.  Genes are# classified into the individual clusters if the EM algorithm# gives them at least a 90% of being in the given clusterfor(i in 1:13) {	plot.wv(Theta, Data, "s", i)}